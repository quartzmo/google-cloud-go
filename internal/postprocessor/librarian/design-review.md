# Go Librarian Onboarding: `generate` - Design Review Talking Points

## Introduction & Objective (5 minutes)

*   **Hook:** Start by stating the current Go client library generation process is complex, slow, and a maintenance burden.
*   **Problem:** We're currently using a legacy toolchain (`bazel-bot`, `OwlBot`) that's inconsistent with the cross-language direction of the 1-Platform-Principle (1PP). It's hard to maintain, debug, and onboard new engineers to.
*   **Proposal:** I'm proposing we migrate our Go client library generation to the new Librarian platform. This involves creating a new, containerized Go generator called `librariangen`.
*   **Primary Goal:** The number one goal is **100% backward compatibility**. The code generated by this new system must be identical to the old one. This is a "lift and shift" migration to a modern platform, not a rewrite of the generated code itself.
*   **Scope:** We'll start by migrating a single, representative library to prove the concept before moving on to the ~190 other libraries in `google-cloud-go`.

## Background & New Workflow (10 minutes)

*   **Recap of Old System:**
    *   Briefly walk through the current 3-step process:
        1.  `bazel-bot` generates code from `googleapis` into an intermediate repo (`googleapis-gen`).
        2.  `OwlBot` copies that code into `google-cloud-go` using `.OwlBot.yaml` rules.
        3.  A Go-specific `OwlBot` post-processor runs in the PR to clean up and add extra files.
    *   Emphasize the distributed nature and multiple points of failure.

*   **Introducing the New `librariangen` Workflow:**
    *   This new process is orchestrated by the central Librarian tool and runs inside a single, self-contained Docker container.
    *   Explain the three commands the container will execute, corresponding to the Librarian contract:
        1.  **`configure`:** An initial, one-time setup for a new library to create its configuration in `state.yaml`.
        2.  **`generate`:** The main event. This is where the code is actually generated.
        3.  **`build`:** A validation step where Librarian runs `go build` and `go test` against the newly generated code in a full repo checkout.
    *   Focus on the **`generate`** step, as it's the core of this proposal.

*   **The `generate` Step - High Level:**
    1.  **Invocation:** Librarian invokes our `librariangen` container.
    2.  **Inputs:** It provides everything needed as mounted directories: `/source` for `googleapis`, `/librarian` for the generation request, and an empty `/output` for the generated code.
    3.  **Execution:** Inside the container, our `librariangen` binary runs. It parses the request, calls `protoc` to generate the Go code, and writes it to the `/output` directory.
    4.  **Post-processing:** A new, lightweight post-processor runs *inside the container* to format code, tidy `go.mod`, and generate `version.go`.
    5.  **Output:** Librarian takes the contents of `/output` and intelligently copies them into the `google-cloud-go` repository.

*   **Key Takeaway:** We're replacing a complex, distributed system with a single, containerized, and hermetic process that is easier to understand, maintain, and secure.

## Technical Deep Dive (10 minutes)

*   **The `librariangen` Container:**
    *   It's a standard Debian 12 container.
    *   It will have specific, pinned versions of Go, `protoc`, and the `protoc-gen-go*` plugins. This ensures reproducible builds.
    *   The entrypoint is our compiled `librariangen` Go binary.

*   **Configuration (`state.yaml` & `generate-request.json`):**
    *   Briefly show the `state.yaml` structure. Explain that this is Librarian's central truth file. Point out `source_paths` (where to put code) and `preserve_regex` (what to not delete).
    *   Show the `generate-request.json`. This is the input to our container, telling it *which* APIs to generate for a given library.

*   **The `gapicgen` Component (The "Generator"):**
    *   This is the heart of the `generate` command.
    *   **Crucially, to start, it will read `BUILD.bazel` files from `googleapis`** to get the `protoc` options. This is a temporary measure to avoid duplicating complex configuration and to ensure we match the existing output exactly. The long-term goal is to move this configuration into the service YAMLs.
    *   Show the example `protoc` command. Highlight that we're just calling the standard tools, but in a more controlled environment. The inputs (`-I`) are simplified because we have the entire `googleapis` repo available.

*   **The `postprocessor` Component:**
    *   **This is a new, lightweight implementation.** We are *not* adapting the old post-processor, which was too complex and had external dependencies (like the GitHub API).
    *   Its job is simple: run `goimports`, `go mod tidy`, generate `version.go`, and run linters. It operates *only* on the `/output` directory.
    *   **Challenge - Shared Files:** Mention the problem of updating shared files like `go.work` or the root `release-please-config.json`. The container is isolated and can't safely modify these without causing merge conflicts. This is a known limitation of the current Librarian model that we will need to address, likely with a separate, repository-level process after generation.

## Rollout, Testing & Risks (5 minutes)

*   **Testing Strategy (Assuring backward compatibility):**
    *   Our testing plan is multi-layered to ensure a zero-diff migration.
    1.  **Manual E2E:** We will manually regenerate ~10 libraries and verify **no diff**.
    2.  **Scripted Onboarding:** A script will then onboard the remaining ~180 libraries, again checking for **no diff**.
    3.  **Automated Docker Tests:** We'll have a CI script that runs the full container workflow for key libraries to catch regressions.
    4.  **Unit Tests:** All new Go code will be fully unit-tested.

*   **Launch Plan (Gradual Rollout):**
    *   This will be a slow, careful migration starting at the end of July.
    1.  **Canary:** Start with one simple library, end-to-end, including a release.
    2.  **Difficult Eight:** Tackle the 8 most complex libraries (like `storage`, `bigquery`).
    3.  **Full Rollout:** Onboard all remaining libraries.
    4.  **Decommission:** Finally, remove the old `bazel-bot` and `OwlBot` configurations.

*   **Risks & Mitigations:**
    *   **Hidden Logic:** `.OwlBot.yaml` or Bazel rules might have subtle logic. **Mitigation:** We'll audit these files before migrating.
    *   **Shared Files:** As mentioned, concurrent updates are a challenge. **Mitigation:** This will likely require a separate, post-generation step.
    *   **Post-processing Discrepancies:** The new post-processor might miss something. **Mitigation:** We will `diff` the output of the old and new systems for every library and adjust as needed.

*   **Call to Action / Next Steps:**
    *   Seeking design approval from the team.
    *   Next steps are to begin implementing the `librariangen` binary and Dockerfile.
    *   Open the floor for questions.